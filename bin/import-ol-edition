#!/usr/bin/env python
import datetime
import json
import pprint
import re
import subprocess
import requests
import pathlib

json_output_path = pathlib.Path(__file__).resolve(strict=True).parent.parent / "allthethings" / "page" / "ol_edition.json"
python_output_path = json_output_path.parent / "openlibrary" / "edition.py"

# first, save the json file from openlibrary into the source tree
source_url = "https://openlibrary.org/config/edition.json"
ol_edition_json = requests.get(source_url).json()

with open(json_output_path, "w") as f:
    f.write(json.dumps(ol_edition_json, indent=4, ensure_ascii=False))

# next, turn each .name key into a gettext identifier
classification_prefix = "org.openlibrary.edition.classification."
classification_regex = re.compile(r"'name': '(org\.openlibrary\.edition\.classification\.[^']+)'")

identifier_prefix = "org.openlibrary.edition.identifier."
identifier_regex = re.compile(r"'name': '(org\.openlibrary\.edition\.identifier\.[^']+)'")

# do a little pre-processing of the JSON, and add the prefixes to the .name keys
for identifier in ol_edition_json['identifiers']:
    if 'url' in identifier:
        identifier['url'] = identifier['url'].replace('@@@', '%s')
    
    if identifier.get('notes') == '':
        del identifier['notes']
    
    if name := identifier.get('name'):
        assert "'" not in name, "the .name key cannot contain single quotes, as the regexes use them to locate the edges of the identifier"
        identifier['name'] = f"{identifier_prefix}{name}"

for classification in ol_edition_json['classifications']:
    if 'website' in classification:
        # Sometimes there's a suffix in text..
        classification['website'] = classification['website'].split(' ')[0]
    
    if classification.get('notes') == '':
        del classification['notes']
    
    if name := classification.get('name'):
        assert "'" not in name, "the .name key cannot contain single quotes, as the regexes use them to locate the edges of the identifier"
        classification['name'] = f"{classification_prefix}{name}"

# now write the updated data to a python file, and replace the .name keys with
# actual gettext calls via regex replacements
with open(python_output_path, "w") as f:
    # Retrieved from https://openlibrary.org/config/edition.json on 2023-07-02
    f.write('# This file is automatically @generated by `bin/import-ol-edition`.\n')
    f.write(f'# Retrieved from {source_url} on {datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%d")}\n')
    f.write('# Do not edit this file directly.\n\n')
    f.write('from flask_babel import gettext\n\n')
    f.write("editions = ")

    # note that pprint will quote strings with single quotes. as such, we use single quotes
    # to locate the edges of the .name keys in the regexes. if this changes, the regexes will
    # need to be updated.
    python_output = pprint.pformat(ol_edition_json, underscore_numbers=True, indent=4, width=120, sort_dicts=True)
    
    # replace classification and identifier names with gettext calls
    python_output = classification_regex.sub(r"'name': gettext('\1')", python_output)
    python_output = identifier_regex.sub(r"'name': gettext('\1')", python_output)

    # add trailing commas to each json object
    python_output = re.sub(r'''([')])},''', r'\1,},', python_output)

    f.write(python_output)
    f.write("\n")

# finally, reformat the output python file so it looks nice
subprocess.run(["ruff", "format", str(python_output_path)], check=True)
